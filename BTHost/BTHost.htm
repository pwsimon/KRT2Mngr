<HTML>

<HEAD>
	<meta http-equiv="X-UA-Compatible" content="IE=11" />
	<!--
		strategie zum debuggen mit den Browser debugging Tools unter zuhilefename eines simulators fuer window.external:
		- fuer eine EIN FILE strategie brauch ich einen precompiler BOWER vor dem deployment
		- solange ich im meiner entwicklungsumgebung das http:// protocol verwende kann ich mit require.js modularisieren
	-->
	<script type="text/javascript" src="winExtFake.js"></script>
	<script type="text/javascript">
var g_cmdParser;
var g_multiCommand = null; // send cmultiple commands context
var g_cmdParserAckNakHandler;

var g_tWaitForAckNak = 0;
var g_tWaitForAckNakTimeout = 1000; // empirischer wert fuer schreiben in den speicher des KRT2

/*
* umstellen von Pseudoklassischer Vererbung (Philip Ackermann S. 145)
* auf Prototypische Vererbung (Philip Ackermann S. 136)
*/
function CommandParser() {
	this.rgCmd = {};
	this.fnVerify; // undefined OR null laeuft hier auf das gleiche hinaus, KEINE verification routine
	this.rgKeys = [];
	this.nIndex = 0;

	// functions
	this.Drive = function (nByte) {
		var sCmd = String.fromCharCode(nByte);

		if (this.nIndex) {
			this.rgCmd[this.rgKeys[this.nIndex]] = nByte;
			this.nIndex++;
			if (this.nIndex == this.rgKeys.length) {
				window.clearTimeout(this.tTimeout);
				return this.fnVerify ? this.fnVerify() : true;
			}
			return false;
		}

		// 1.2 Out-going strings (from Radio after changing on panel):
		// single byte commands
		else if ("O" == sCmd) {
			// 1.2.6 DUAL-mode on, vgl. 1.3.7 DUAL-mode on
			this.rgCmd = { sCmd: sCmd };
			this.fnVerify = null; // single byte commands haben generell KEINE verification function
			/*
			* wird mit dem constructor (STX) gestartet
			* fuer MultiByte commands wird der Timeout, zentral, mit der bedingung (this.nIndex == this.rgKeys.length) zurueckgesetzt
			*/
			window.clearTimeout(this.tTimeout);
			return true;
		}

		else if ("o" == sCmd) {
			this.rgCmd = { sCmd: sCmd };
			this.fnVerify = null; // single byte commands haben generell KEINE verification function
			window.clearTimeout(this.tTimeout); // wird mit dem constructor (STX) gestartet
			return true;
		}

		// MultiByte commands
		else if ("R" == sCmd) {
			this.rgCmd = { sCmd: sCmd, nMHZ: 0, nkHZ: 0, sStation0: ' ', sStation1: ' ', sStation2: ' ', sStation3: ' ', sStation4: ' ', sStation5: ' ', sStation6: ' ', sStation7: ' ', nNr: 0, nChkSum: 0 };
			/*
			* die this.fnVerify() funktion wird ausgefuehrt wenn das letzte Byte eines commands gelesen wurde
			* fnVerifyChkSum() liefert eine funktion die folgenden ausdruck verifiziert (eval): 'nMHZ' ^ 'nkHZ' == 'nChkSum'
			*/
			this.fnVerify = this.fnVerifyChkSum('nMHZ', 'nkHZ', 'nChkSum');
		}

		else if ("U" == String.fromCharCode(nByte)) {
			this.rgCmd = { sCmd: sCmd, nMHZ: 0, nkHZ: 0, sStation0: ' ', sStation1: ' ', sStation2: ' ', sStation3: ' ', sStation4: ' ', sStation5: ' ', sStation6: ' ', sStation7: ' ', nChkSum: 0 };
			this.fnVerify = null; // KEIN(E) verify (funktion) nachdem alle bytes des command gelesen wurden
		}

		this.rgKeys = Object.keys(this.rgCmd);
		this.nIndex = 1;
	}
	this.fnVerifyChkSum = function (sNamedId1, sNamedId2, sNamedIdResult) {
		return function() { return this.rgCmd[sNamedIdResult] == this.rgCmd[sNamedId1] ^ this.rgCmd[sNamedId2] };
	}
	this.tTimeout = window.setTimeout(function () {
		console.log("reset the global parser");
		document.getElementById('lblCommand').innerText = "reset the global parser";
		g_cmdParser = null; // enter IDLE
	}, 5000); // 9600 baud => 100 Char/Sec => 50 Char/0.5 Sec
}

/*
* der folgende abschnitt ist die schnittstelle in die GUI
* siehe auch:
*   ..\IByteLevel.js
*/
function OnRXSingleByte(nByte) {
	/*
	* document.getElementById('lblCommand').innerText = String.fromCharCode(nByte);
	* solange ein parser (g_cmdParser) active ist muss dieser die hoechste prioritaet haben
	*/
	if (g_cmdParser) {
		if (g_cmdParser.Drive(nByte)) {
			// console.log("finished:", g_cmdParser.rgCmd.sCmd);
			document.getElementById('lblCommand').innerText = "finished: " + g_cmdParser.rgCmd.sCmd;
			g_cmdParser = null; // enter IDLE
		}
	}

	else if("S".charCodeAt(0) == nByte) {
		console.log("ping");
		document.getElementById('lblCommand').innerText = "ping";
	}

	else if (2 == nByte) { // STX
		if (g_cmdParser)
			console.log("previous command unsuccessfull/interrupted");

		g_cmdParser = new CommandParser();
	}

	else if (6 == nByte && g_cmdParserAckNakHandler) { // ACK
		console.log("delegate ACK to initiator of txBytes()");
		g_cmdParserAckNakHandler.call(g_multiCommand, nByte);
	}

	else if (15 == nByte && g_cmdParserAckNakHandler) { // NAK
		console.log("delegate NAK to initiator of txBytes()");
		g_cmdParserAckNakHandler.call(g_multiCommand, nByte);
	}

	else {
		console.log("invalid sequence");
	}
}
/*
* sowohl sendSingleCommand() als auch sind sendCommandAndVerify() nonblocking
* Hinweis:
* obwohl es vermutlich eine verbesserung im durchsatz ergaebe wollen wir aktuell KEIN callback
* als bestaetigung fuer das vollstaendige versenden des command implementieren.
* die bestaetigung/callback soll ueber OnRXSingleByte()/g_cmdParserAckNakHandler generiert/getriggert werden
* - die "einfachere" schnittstelle zum host hat hier prioritaet
*/
function sendMultipleCommands() {
	sendCommandAndVerify({
			rgCommands: [
				"0x02 0x43",                                                        // Interface_Ext_V18.pdf(5), 1.3.2 Exchange of Frequencies (active against passive)
				"0x02 0x52 0x7b 0x64 0x47 0x65 0x72 0x61 0x74 0x73 0x68 0x66 0x1f", // Interface_Ext_V18.pdf(5), 1.3.3 Set passive frequency (MHz,KHz) & name
				"0x02 0x55 0x7b 0x64 0x47 0x65 0x72 0x61 0x74 0x73 0x68 0x66 0x1f"  // Interface_Ext_V18.pdf(5), 1.3.4 Set active frequency (MHz,KHz) & name
				],
			nIndex: 0
		});
}
function getMultipleCommandsCtx() {
	return {
			rgCommands: [
				// { STX, 'C' }; // 1.3.2 Exchange of Frequencies (active against passive)
				"0x02 0x43",

				// { STX, 'R', 123, 500, 'P', 'E', 'T', 'E', 'R', ' ', ' ', ' ', chkSum }; // 1.3.3 Set passive frequency (MHz,KHz) & name
				"0x02 0x52 0x7e 0xb4 0x50 0x45 0x54 0x45 0x52 0x20 0x20 0x20 0xca",

				// { STX, 'U', 123, 500, 'P', 'E', 'T', 'E', 'R', ' ', ' ', ' ', chkSum }; // 1.3.4 Set active frequency (MHz,KHz) & name
				"0x02 0x55 0x7e 0xb4 0x50 0x45 0x54 0x45 0x52 0x20 0x20 0x20 0xca"
			],
		nIndex: 0
		};
}
function sendSingleCommand() {
	/*
	* 1.3 Receiving strings from Remote
	* Hinweis(e)
	*   fire and forget, no verification
	*/
	WinExt.txBytes("0x02 0x4f"); // { STX, 'O' }; // 1.3.7 DUAL-mode on
	// WinExt.txBytes("0x02 0x6f"); // { STX, 'o' }; // 1.3.8 DUAL-mode off
}
function sendCommandAndVerify(oMultiCommand) {
	if ("string" == typeof oMultiCommand) {
		g_multiCommand = { rgCommands: [oMultiCommand], nIndex: 0 };
	} else
		g_multiCommand = oMultiCommand;

	/*
	* 1.3 Receiving strings from Remote
	* Hinweis(e)
	*   verify accept/timeout
	* bytes send asynchronous/nonblocking, you will be notified (Ack/Nak) via OnRXSingleByte
	*/

	/*
	* wir duerfen KEIN Command SENDEN solange wir die bytes fuer ein Command EMPFANGEN denn:
	* der payload eines command kann auch ein ACK/NAK enthalten
	* das wuerden wir evtl. als antwort auf unser gesendetes Command interpretieren/zuordnen.
	*/
	console.assert(null == g_cmdParser, "null == g_cmdParser");

	/*
	* wir duerfen KEIN Command SENDEN solange wir fuer das vorangegangene kein ACK/NAK empfangen haben denn:
	* wir duerfen den empfaenger NICHT ueberfahren (der hat evtl. keinen puffer)
	*/
	console.assert(null == g_cmdParserAckNakHandler, "null == g_cmdParserAckNakHandler");
	console.assert(0 == g_tWaitForAckNak, "0 == g_tWaitForAckNak");

	g_tWaitForAckNak = window.setTimeout(function () {
		g_cmdParserAckNakHandler.call(g_multiCommand, 15);
		console.assert(null == g_cmdParserAckNakHandler, "null == g_cmdParserAckNakHandler");
	}, g_tWaitForAckNakTimeout);

	g_cmdParserAckNakHandler = function (nByte) {
		if (15 == nByte) {
			console.log("failed");
			// return; // break
		} else
			console.log("succeeded");

		console.assert(0 != g_tWaitForAckNak, "0 != g_tWaitForAckNak");
		window.clearTimeout(g_tWaitForAckNak);

		this.nIndex += 1; // check for continue
		if (this.nIndex < this.rgCommands.length) {
			g_tWaitForAckNak = window.setTimeout(function () {
				g_cmdParserAckNakHandler.call(g_multiCommand, 15);
				console.assert(null == g_cmdParserAckNakHandler, "null == g_cmdParserAckNakHandler");
			}, g_tWaitForAckNakTimeout);
			WinExt.txBytes(this.rgCommands[this.nIndex]);
		} else
			g_cmdParserAckNakHandler = null; // command finished
	}

	// start by sending the very first command
	WinExt.txBytes(g_multiCommand.rgCommands[0]);
}
window.onload = function () {
	// alert("documentMode: " + document.documentMode + ", compatMode: " + document.compatMode);
	/* OnRXSingleByte(2); // STX
	OnRXSingleByte("O".charCodeAt(0));

	OnRXSingleByte(2); // STX
	OnRXSingleByte("U".charCodeAt(0));
	OnRXSingleByte(123);
	OnRXSingleByte(500);
	OnRXSingleByte("G".charCodeAt(0));
	OnRXSingleByte("e".charCodeAt(0));
	OnRXSingleByte("r".charCodeAt(0));
	OnRXSingleByte("a".charCodeAt(0));
	OnRXSingleByte("t".charCodeAt(0));
	OnRXSingleByte("s".charCodeAt(0));
	OnRXSingleByte("H".charCodeAt(0));
	OnRXSingleByte("f".charCodeAt(0));
	OnRXSingleByte(256); // nChkSum

	OnRXSingleByte("S".charCodeAt(0));

	OnRXSingleByte(2); // STX
	OnRXSingleByte("R".charCodeAt(0));
	OnRXSingleByte(123);
	OnRXSingleByte(500);
	OnRXSingleByte("G".charCodeAt(0));
	OnRXSingleByte("e".charCodeAt(0));
	OnRXSingleByte("r".charCodeAt(0));
	OnRXSingleByte("a".charCodeAt(0));
	OnRXSingleByte("t".charCodeAt(0));
	OnRXSingleByte("s".charCodeAt(0));
	OnRXSingleByte("H".charCodeAt(0));
	OnRXSingleByte("f".charCodeAt(0));
	OnRXSingleByte(0); // nNr (Slot)
	OnRXSingleByte(256); // nChkSum */
}
	</script>
</HEAD>

<BODY ID=CBTHostDlg BGCOLOR=LIGHTGREY style="font-family:MS Shell Dlg;font-size:8">

<TABLE WIDTH=100% HEIGHT=100%>
	<TR WIDTH=100% HEIGHT=45%>
		<TD ID="lblCommand" ALIGN=CENTER VALIGN=BOTTOM>empty</TD>
	</TR>
	<TR WIDTH=100% HEIGHT=100%>
		<TD ALIGN=RIGHT VALIGN=BOTTOM>
			<BUTTON ID="btnSoft1">undefined</BUTTON>&nbsp;
			<BUTTON ID="btnSoft2">undefined</BUTTON>&nbsp;
			<BUTTON onclick="sendSingleCommand()">fireAndForget</BUTTON>&nbsp;
			<BUTTON onclick="sendMultipleCommands()">sendMultipleCommands</BUTTON>
		</TD>
	</TR>
</TABLE>

</BODY>
</HTML>
